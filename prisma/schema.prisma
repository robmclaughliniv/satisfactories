// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model
model User {
  id          String      @id @default(uuid())
  email       String      @unique
  name        String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  worlds      World[]
}

// Game world representation
model World {
  id          String      @id @default(uuid())
  name        String
  description String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  userId      String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  factories   Factory[]
  resources   Resource[]
}

// Factory representation
model Factory {
  id              String          @id @default(uuid())
  name            String
  description     String?
  location        String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  worldId         String
  world           World           @relation(fields: [worldId], references: [id], onDelete: Cascade)
  buildings       Building[]
  inputs          ItemFlow[]      @relation("FactoryInputs")
  outputs         ItemFlow[]      @relation("FactoryOutputs")
  resourceInputs  ResourceInput[]
  resourceOutputs ResourceOutput[]
  // Factory as origin/destination for resources
  asOrigin        InputResource[] @relation("FactoryOrigin")
  asDestination   OutputResource[] @relation("FactoryDestination")
}

// Resource Input for a Factory
model ResourceInput {
  id          String          @id @default(uuid())
  name        String?
  description String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  factoryId   String
  factory     Factory         @relation(fields: [factoryId], references: [id], onDelete: Cascade)
  resources   InputResource[]
}

// Resource Output for a Factory
model ResourceOutput {
  id          String           @id @default(uuid())
  name        String?
  description String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  factoryId   String
  factory     Factory          @relation(fields: [factoryId], references: [id], onDelete: Cascade)
  resources   OutputResource[]
}

// Input Resource with origin
model InputResource {
  id              String        @id @default(uuid())
  rate            Float         // Items per minute
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  itemId          String
  item            Item          @relation(fields: [itemId], references: [id])
  resourceInputId String
  resourceInput   ResourceInput @relation(fields: [resourceInputId], references: [id], onDelete: Cascade)
  
  // Origin can be either a Resource Node or another Factory
  resourceNodeId  String?
  resourceNode    Resource?     @relation("ResourceNodeOrigin", fields: [resourceNodeId], references: [id])
  factoryOriginId String?
  factoryOrigin   Factory?      @relation("FactoryOrigin", fields: [factoryOriginId], references: [id])
}

// Output Resource with destination
model OutputResource {
  id                String         @id @default(uuid())
  rate              Float          // Items per minute
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  itemId            String
  item              Item           @relation(fields: [itemId], references: [id])
  resourceOutputId  String
  resourceOutput    ResourceOutput @relation(fields: [resourceOutputId], references: [id], onDelete: Cascade)
  
  // Destination is another Factory
  factoryDestinationId String?
  factoryDestination   Factory?     @relation("FactoryDestination", fields: [factoryDestinationId], references: [id])
}

// Building representation (constructors, assemblers, etc.)
model Building {
  id          String      @id @default(uuid())
  name        String
  type        String
  quantity    Int         @default(1)
  clockSpeed  Float       @default(100.0) // Percentage
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  factoryId   String
  factory     Factory     @relation(fields: [factoryId], references: [id], onDelete: Cascade)
  recipeId    String?
  recipe      Recipe?     @relation(fields: [recipeId], references: [id])
  inputs      ItemFlow[]  @relation("BuildingInputs")
  outputs     ItemFlow[]  @relation("BuildingOutputs")
  
  // Reference to game building data
  gameClassName String?
  gameBuilding  GameBuilding? @relation(fields: [gameClassName], references: [className])
}

// Recipe representation
model Recipe {
  id          String      @id @default(uuid())
  name        String      @unique
  description String?
  craftTime   Float       // In seconds
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  buildings   Building[]
  recipeItems RecipeItem[]
  
  // Reference to game recipe data
  gameClassName String?
  gameRecipe    GameRecipe? @relation(fields: [gameClassName], references: [className])
}

// Recipe input/output items
model RecipeItem {
  id          String      @id @default(uuid())
  quantity    Float
  itemId      String
  item        Item        @relation(fields: [itemId], references: [id])
  recipeId    String
  recipe      Recipe      @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  isInput     Boolean     // true for input, false for output

  @@index([recipeId, isInput])
}

// Item representation (iron ore, iron plate, etc.)
model Item {
  id              String           @id @default(uuid())
  name            String           @unique
  description     String?
  category        String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  recipeItems     RecipeItem[]
  itemFlows       ItemFlow[]
  inputResources  InputResource[]
  outputResources OutputResource[]
  
  // Reference to game item data
  gameClassName   String?
  gameItem        GameItem?        @relation(fields: [gameClassName], references: [className])
}

// Resource node representation
model Resource {
  id          String          @id @default(uuid())
  type        String          // e.g., Iron, Copper, Coal
  purity      String          // Impure, Normal, Pure
  location    String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  worldId     String
  world       World           @relation(fields: [worldId], references: [id], onDelete: Cascade)
  // Resource node as origin for input resources
  asOrigin    InputResource[] @relation("ResourceNodeOrigin")
}

// Flow of items between buildings or factories
model ItemFlow {
  id          String      @id @default(uuid())
  rate        Float       // Items per minute
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  itemId      String
  item        Item        @relation(fields: [itemId], references: [id])
  
  // Building relations
  sourceBuilding    Building?  @relation("BuildingOutputs", fields: [sourceBuildingId], references: [id])
  sourceBuildingId  String?
  targetBuilding    Building?  @relation("BuildingInputs", fields: [targetBuildingId], references: [id])
  targetBuildingId  String?
  
  // Factory relations
  sourceFactory     Factory?   @relation("FactoryOutputs", fields: [sourceFactoryId], references: [id])
  sourceFactoryId   String?
  targetFactory     Factory?   @relation("FactoryInputs", fields: [targetFactoryId], references: [id])
  targetFactoryId   String?
}

// ======= GAME DATA MODELS =======

// Game Item data from Satisfactory wiki
model GameItem {
  className     String    @id
  name          String
  description   String?
  stackSize     Int?
  energy        Float?
  radioactive   Float?
  canBeDiscarded Boolean?
  sinkPoints    Int?
  abbreviation  String?
  form          String?   // solid, liquid, gas
  fluidColor    String?
  alienItem     Boolean?
  stable        Boolean?
  experimental  Boolean?
  
  // Relations
  items         Item[]
  asInput       GameRecipeItem[] @relation("GameItemInput")
  asOutput      GameRecipeItem[] @relation("GameItemOutput")
}

// Game Recipe data from Satisfactory wiki
model GameRecipe {
  className     String    @id
  name          String
  unlockedBy    String?
  duration      Float     // In seconds
  alternate     Boolean?
  inCraftBench  Boolean?
  inWorkshop    Boolean?
  inBuildGun    Boolean?
  inCustomizer  Boolean?
  manualCraftingMultiplier Float?
  minPower      Float?
  maxPower      Float?
  stable        Boolean?
  experimental  Boolean?
  
  // Relations
  recipes       Recipe[]
  recipeItems   GameRecipeItem[]
  producedIn    GameRecipeBuilding[]
}

// Game Recipe Item (inputs/outputs)
model GameRecipeItem {
  id            String    @id @default(uuid())
  amount        Float
  isInput       Boolean   // true for input, false for output
  
  // Relations
  recipeId      String
  recipe        GameRecipe @relation(fields: [recipeId], references: [className], onDelete: Cascade)
  
  // Item relations - one field for the actual relation, but we need to map to different relations
  itemId        String
  inputItem     GameItem  @relation("GameItemInput", fields: [itemId], references: [className], map: "GameRecipeItem_inputItem_fkey")
  outputItem    GameItem  @relation("GameItemOutput", fields: [itemId], references: [className], map: "GameRecipeItem_outputItem_fkey")

  @@index([recipeId, isInput])
}

// Game Building data from Satisfactory wiki
model GameBuilding {
  className     String    @id
  name          String
  description   String?
  unlockedBy    String?
  powerUsage    Float?
  powerGenerated Float?
  supplementPerMinute Float?
  overclockable Boolean?
  somersloopSlots Int?
  isVehicle     Boolean?
  stable        Boolean?
  experimental  Boolean?
  
  // Relations
  buildings     Building[]
  recipes       GameRecipeBuilding[]
}

// Many-to-many relation between GameRecipe and GameBuilding
model GameRecipeBuilding {
  id            String    @id @default(uuid())
  recipeId      String
  recipe        GameRecipe @relation(fields: [recipeId], references: [className], onDelete: Cascade)
  buildingId    String
  building      GameBuilding @relation(fields: [buildingId], references: [className], onDelete: Cascade)
  
  @@unique([recipeId, buildingId])
}
